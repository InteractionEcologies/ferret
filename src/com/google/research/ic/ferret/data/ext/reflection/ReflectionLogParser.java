package com.google.research.ic.ferret.data.ext.reflection;

import com.google.gson.Gson;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonElement;
import com.google.research.ic.ferret.data.Event;
import com.google.research.ic.ferret.data.ParallelTaskExecutor;
import com.google.research.ic.ferret.data.Parser;
import com.google.research.ic.ferret.data.SearchEngine;
import com.google.research.ic.ferret.data.Snippet;
import com.google.research.ic.ferret.data.attributes.Attribute;
import com.google.research.ic.ferret.test.Debug;
import com.google.research.reflection.data.Observation;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * TODO: Insert description here. (generated by liyang)
 */
public class ReflectionLogParser implements Parser {
  
  public static final String DEFAULT_LOG_DIRECTORY = 
      System.getProperty("user.home") + File.separator +
      "reflection-logs";
  public static final String DEFAULT_DEMO_DIRECTORY = 
      DEFAULT_LOG_DIRECTORY + File.separator + "sample-queries";

  private static final long SEGMENTATION_INTERVAL = 600 * 1000;
  
  Observation lastObservation;
  private static ReflectionLogParser theParser = null;
  
  private ReflectionLogParser() {}
  
  
  public static ReflectionLogParser getParser () {
    if (theParser == null) {
      theParser = new ReflectionLogParser();
    }
    return theParser;
  }
  
  @Override
  public List<Snippet> readLogDirectory(String dirName) {
    
    if (dirName == null) {
      dirName = DEFAULT_LOG_DIRECTORY;
    }
    
    ArrayList<Snippet> snippets = new ArrayList<Snippet>();
    File logDir = new File(dirName);
    FileFilter filter = new FileFilter() {
      @Override
      public boolean accept(File file) {
        return (file.getName().endsWith(".txt") || 
            file.getName().endsWith(".db") ||
            file.getName().endsWith(".log") ||
            file.getName().endsWith(".json"));
      }
    };
    File[] logFiles = logDir.listFiles(filter);
    for (int i = 0; i < logFiles.length; i++) {
      File logFile = logFiles[i];
      snippets.addAll(readLogFile(logFile));
    }
    return snippets;
  }

  public List<Snippet> readLogFile(String logFileName) {
    return readLogFile(new File(logFileName));
  }
  
  public List<Snippet> readLogFile(File logFile) {
    Debug.log("Reading log file: " + logFile.getName());
    long time = System.currentTimeMillis();
    HashMap<String, ArrayList<Observation>> tmp = 
        new HashMap<String, ArrayList<Observation>>();
    DataInputStream input = null;
    int added = 0;
    try {
      input = new DataInputStream(
          new BufferedInputStream(new FileInputStream(logFile)));
      while (input.available() > 0) {
        String evt = input.readUTF();
        //Debug.log("Read input: " + evt);
        if (evt == null) {
          break;
        }
        Observation observation = new Gson().fromJson(evt, Observation.class);
        //Debug.log("Created observation: " + observation);

        ArrayList<Observation> list = tmp.get(observation.getDevice());
        if (list == null) {
          list = new ArrayList<Observation>();
          tmp.put(observation.getDevice(), list);
        }
        list.add(observation);
        added++;
      }
      input.close();
    } catch (IOException e) {
      e.printStackTrace();
    } finally {
      try {
        input.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    List<Snippet> snippets = new ArrayList<Snippet>();
    for (Map.Entry<String, ArrayList<Observation>> entry : tmp.entrySet()) {
      Snippet snippet = null;
      long lastTime = 0;
      for (Observation observation : entry.getValue()) {
        if (observation.getTime() < lastTime) {
          throw new RuntimeException();
        }
        if (observation.getTime() - lastTime > SEGMENTATION_INTERVAL) {
          snippet = new Snippet();
          snippets.add(snippet);
        }
        if (snippet != null) {
          snippet.addEvent(new ReflectionEvent(observation));
        }
        lastTime = observation.getTime();
      }
    }
    long duration = System.currentTimeMillis() - time;
    System.err.println("#snippets:" + snippets.size() + 
        " #events:" + added + " #suers:" + tmp.size() + 
        " #seconds:" + (duration / 1000));
    return snippets;
  }
  
  @Override
  public List<Snippet> readDemoDirectory(String demoDirName) {
    if (demoDirName == null) {
      demoDirName = DEFAULT_DEMO_DIRECTORY;
    }
    return readLogDirectory(demoDirName);

  }
  
  @Override
  public List<Attribute> getAvailableAttributes() {
    List<Attribute> attributes = new ArrayList<Attribute>();

    return attributes;
   
  }
  
  public void startRecordDemonstration() {
    lastObservation = null;
  }

  /**
   * @return when returning null, there is no event to be added to the UI.
   */
  @Override
  public Event parseEvent(String gsonString) {
    Observation observation = new Gson().fromJson(gsonString, Observation.class);
    if (observation.isDebugMessage) {
      return null;
    }
    Event evt = null;
    if (lastObservation == null || observation.getTime() != lastObservation.getTime() ||
        !observation.equals(lastObservation)) {
      evt = new ReflectionEvent(observation);
      if (lastObservation != null) {
        lastObservation.setDuration(
            (int) ((observation.getTime() - lastObservation.getTime()) / 1000));
        // Merge the adjacent same events.
        if (lastObservation.getEventName().equals(observation.getEventName())) {
          evt = null;
        }
      }
    }
    lastObservation = observation;
    return evt;
  }

  public void writeSnippet(Snippet snip, File file) {
    DataOutputStream output = null;
    try {
      output = new DataOutputStream(
          new BufferedOutputStream(new FileOutputStream(file)));
    } catch (IOException e) {
      e.printStackTrace();
    }
    
    for (Event evt : snip.getEvents()) {      
      writeEvent(evt, output);
    }
    try {
      output.flush();
      output.close();
    } catch (IOException e) {
      e.printStackTrace();
    }

  }
  
  public void writeEvent(Event evt, File file) {
    if (file != null) {
      try {
        DataOutputStream output = new DataOutputStream(
            new BufferedOutputStream(new FileOutputStream(file)));
        writeEvent(evt, output);
        output.flush();
        output.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }

  public void writeEvent(Event evt, DataOutputStream output) {
    if (!(evt instanceof ReflectionEvent)) {
      throw new IllegalArgumentException(
          "ReflectionLogParser can't write out event " + evt);
    }
    ReflectionEvent rEvt = (ReflectionEvent) evt;
    Observation obs = rEvt.getObservation();
    
    if (output != null) {
      try {
        String jsonString = new Gson().toJson(obs);
        output.writeUTF(jsonString);
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
  
  @Override
  public Event deserializeEvent(JsonElement json, Type klass, JsonDeserializationContext jdContext) {
    return jdContext.deserialize(json, ReflectionEvent.class);    
  }

  public static void main(String[] args) {
    List<Snippet> snippets = new ReflectionLogParser().readLogFile(args[0]);
    long time = System.currentTimeMillis();
    SearchEngine.getSearchEngine().indexSubSequences(snippets, true);
    long duration = System.currentTimeMillis() - time;
    System.err.println("indexing time: " + (duration / 1000) + " seconds");
    ParallelTaskExecutor.shutdown();
  }
}
