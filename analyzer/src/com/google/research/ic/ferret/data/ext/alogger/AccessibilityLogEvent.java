/*******************************************************************************
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package com.google.research.ic.ferret.data.ext.alogger;

import com.google.research.ic.ferret.Config;
import com.google.research.ic.ferret.data.Event;
import com.google.research.ic.ferret.data.SearchEngine;
import com.google.research.ic.ferret.test.Debug;

import java.io.StringWriter;
import java.lang.reflect.Field;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.HashMap;

/**
 * TODO: Insert description here. (generated by marknewman)
 */
public class AccessibilityLogEvent extends Event
  implements Comparable<AccessibilityLogEvent> {

  // TODO: make it so that ALogger and QBDILA share these event definitions

  // these are now superclass members
  //  private String userId = null;
  //  private String deviceId = null;
  //  private long timeStamp = -1;  

  private int eventType = -1;
  private String wText = null;
  //private ArrayList<String> wAccessibilityRecordText = null;
  private String wClassName = null;
  private String wPackageName = null;
  private String wResourceName = null;
  private int wHeight = -1;
  private int wWidth = -1;
  private float wRelativeHeight = -1;
  private float wRelativeWidth = -1;
  private int wXPos = -1;
  private int wYPos = -1;
  private float wRelativeXPos = -1;
  private float wRelativeYPos = -1;
  private boolean wIsEnabled = false;
  private boolean wIsChecked = false;
  private boolean wIsFocused = false;
  private boolean wIsFocusable = false;
  private boolean wIsCheckable = false;

  private PathToRoot pathToRoot = null;
  
  private static ALoggerDistanceWeights weights = new ALoggerDistanceWeights();  
  
  // These constants are copied from 
  // http://developer.android.com/reference/android/view/accessibility/AccessibilityEvent.html
  public static final int TYPE_ANNOUNCEMENT = 0x00004000;
  public static final int TYPE_GESTURE_DETECTION_END = 0x00080000;
  public static final int TYPE_GESTURE_DETECTION_START = 0x00040000;
  public static final int TYPE_NOTIFICATION_STATE_CHANGED = 0x00000040;
  public static final int TYPE_TOUCH_EXPLORATION_GESTURE_END = 0x00000400;
  public static final int TYPE_TOUCH_EXPLORATION_GESTURE_START = 0x00000200;
  public static final int TYPE_TOUCH_INTERACTION_END = 0x00200000;
  public static final int TYPE_TOUCH_INTERACTION_START = 0x00100000;
  public static final int TYPE_VIEW_ACCESSIBILITY_FOCUSED = 0x00008000;
  public static final int TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED = 0x00010000;
  public static final int TYPE_VIEW_CLICKED = 0x00000001;
  public static final int TYPE_VIEW_FOCUSED = 0x00000008;
  public static final int TYPE_VIEW_HOVER_ENTER = 0x00000080;
  public static final int TYPE_VIEW_HOVER_EXIT = 0x00000100;
  public static final int TYPE_VIEW_LONG_CLICKED = 0x00000002;
  public static final int TYPE_VIEW_SCROLLED = 0x00001000;
  public static final int TYPE_VIEW_SELECTED = 0x00000004;
  public static final int TYPE_VIEW_TEXT_CHANGED = 0x00000010;
  public static final int TYPE_VIEW_TEXT_SELECTION_CHANGED = 0x00002000;
  public static final int TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY = 0x00020000;
  public static final int TYPE_WINDOWS_CHANGED = 0x00400000;
  public static final int TYPE_WINDOW_CONTENT_CHANGED = 0x00000800;
  public static final int TYPE_WINDOW_STATE_CHANGED = 0x00000020;
  
  public static final String TYPE_ANNOUNCEMENT_NAME = "ANNOUNCEMENT";
  public static final String TYPE_GESTURE_DETECTION_END_NAME = "GESTURE END";
  public static final String TYPE_GESTURE_DETECTION_START_NAME = "GESTURE START";
  public static final String TYPE_NOTIFICATION_STATE_CHANGED_NAME = "NOTIF CHANGE";
  public static final String TYPE_TOUCH_EXPLORATION_GESTURE_END_NAME = "EXPLORATION GESTURE END";
  public static final String TYPE_TOUCH_EXPLORATION_GESTURE_START_NAME = "EXPLORATION GESTURE START";
  public static final String TYPE_TOUCH_INTERACTION_END_NAME = "TOUCH END";
  public static final String TYPE_TOUCH_INTERACTION_START_NAME = "TOUCH START";
  public static final String TYPE_VIEW_ACCESSIBILITY_FOCUSED_NAME = "ACCESSIBILITY FOCUSED";
  public static final String TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED_NAME = "ACCESSIBILITY FOCUS CLEARED";
  public static final String TYPE_VIEW_CLICKED_NAME = "CLICK";
  public static final String TYPE_VIEW_FOCUSED_NAME = "FOCUS";
  public static final String TYPE_VIEW_HOVER_ENTER_NAME = "HOVER";
  public static final String TYPE_VIEW_HOVER_EXIT_NAME = "HOVER EXIT";
  public static final String TYPE_VIEW_LONG_CLICKED_NAME = "LONG CLICKED";
  public static final String TYPE_VIEW_SCROLLED_NAME = "SCROLL";
  public static final String TYPE_VIEW_SELECTED_NAME = "SELECT";
  public static final String TYPE_VIEW_TEXT_CHANGED_NAME = "TEXT CHANGE";
  public static final String TYPE_VIEW_TEXT_SELECTION_CHANGED_NAME = "SELECT TEXT";
  public static final String TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY_NAME = "TEXT TRAVERSAL";
  public static final String TYPE_WINDOWS_CHANGED_NAME = "SHOW";
  public static final String TYPE_WINDOW_CONTENT_CHANGED_NAME = "UPDATE";
  public static final String TYPE_WINDOW_STATE_CHANGED_NAME = "POPUP";

  private int[] generousFilterEvents = {
    TYPE_ANNOUNCEMENT,
    TYPE_TOUCH_EXPLORATION_GESTURE_END,
    TYPE_TOUCH_EXPLORATION_GESTURE_START,
    TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED,
    TYPE_VIEW_ACCESSIBILITY_FOCUSED,
    TYPE_WINDOW_CONTENT_CHANGED,
    TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY
  };
  
  private int[] aggressiveFilterEvents = {
    TYPE_VIEW_FOCUSED,
    TYPE_VIEW_SCROLLED
  };
  
  boolean important = false;
  boolean startCandidate = false;
  boolean stopCandidate = false;
  
  private static HashMap<Integer, String> eventNameMap = new HashMap<Integer, String>();
  
  static {
    eventNameMap.put(new Integer(TYPE_ANNOUNCEMENT), TYPE_ANNOUNCEMENT_NAME);
    eventNameMap.put(new Integer(TYPE_GESTURE_DETECTION_START), TYPE_GESTURE_DETECTION_START_NAME);
    eventNameMap.put(new Integer(TYPE_GESTURE_DETECTION_END), TYPE_GESTURE_DETECTION_END_NAME);
    eventNameMap.put(new Integer(TYPE_NOTIFICATION_STATE_CHANGED), TYPE_NOTIFICATION_STATE_CHANGED_NAME);
    eventNameMap.put(new Integer(TYPE_TOUCH_EXPLORATION_GESTURE_END), TYPE_TOUCH_EXPLORATION_GESTURE_END_NAME);
    eventNameMap.put(new Integer(TYPE_TOUCH_EXPLORATION_GESTURE_START), TYPE_TOUCH_EXPLORATION_GESTURE_START_NAME);
    eventNameMap.put(new Integer(TYPE_TOUCH_INTERACTION_END), TYPE_TOUCH_INTERACTION_END_NAME);
    eventNameMap.put(new Integer(TYPE_TOUCH_INTERACTION_START), TYPE_TOUCH_INTERACTION_START_NAME);
    eventNameMap.put(new Integer(TYPE_VIEW_ACCESSIBILITY_FOCUSED), TYPE_VIEW_ACCESSIBILITY_FOCUSED_NAME);
    eventNameMap.put(new Integer(TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED), TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED_NAME);
    eventNameMap.put(new Integer(TYPE_VIEW_CLICKED), TYPE_VIEW_CLICKED_NAME);
    eventNameMap.put(new Integer(TYPE_VIEW_FOCUSED), TYPE_VIEW_FOCUSED_NAME);
    eventNameMap.put(new Integer(TYPE_VIEW_HOVER_ENTER), TYPE_VIEW_HOVER_ENTER_NAME);
    eventNameMap.put(new Integer(TYPE_VIEW_HOVER_EXIT), TYPE_VIEW_HOVER_EXIT_NAME);
    eventNameMap.put(new Integer(TYPE_VIEW_LONG_CLICKED), TYPE_VIEW_LONG_CLICKED_NAME);
    eventNameMap.put(new Integer(TYPE_VIEW_SCROLLED), TYPE_VIEW_SCROLLED_NAME);
    eventNameMap.put(new Integer(TYPE_VIEW_SELECTED), TYPE_VIEW_SELECTED_NAME);
    eventNameMap.put(new Integer(TYPE_VIEW_TEXT_CHANGED), TYPE_VIEW_TEXT_CHANGED_NAME);
    eventNameMap.put(new Integer(TYPE_VIEW_TEXT_SELECTION_CHANGED), TYPE_VIEW_TEXT_SELECTION_CHANGED_NAME);
    eventNameMap.put(new Integer(TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY), TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY_NAME);
    eventNameMap.put(new Integer(TYPE_WINDOWS_CHANGED), TYPE_WINDOWS_CHANGED_NAME);
    eventNameMap.put(new Integer(TYPE_WINDOW_CONTENT_CHANGED), TYPE_WINDOW_CONTENT_CHANGED_NAME);
    eventNameMap.put(new Integer(TYPE_WINDOW_STATE_CHANGED), TYPE_WINDOW_STATE_CHANGED_NAME);
  }
  
  protected static final class PathToRoot {
    protected ArrayList<String> ancestorClassNames = new ArrayList<>();
    protected ArrayList<Integer> ancestorIndices = new ArrayList<>();
    protected int depthFromRoot = -1;

    //for testing
    public PathToRoot(int depth, ArrayList<String> ancestorClassNames, ArrayList<Integer> ancestorIndices) {
      this.depthFromRoot = depth;
      this.ancestorClassNames = ancestorClassNames;
      this.ancestorIndices = ancestorIndices;
    }
    
    @Override
    public String toString() {
      StringWriter sw = new StringWriter();
      sw.append("PTR: ");
      sw.append("DFR: " + depthFromRoot);
      sw.append(", ancestors: " + ancestorClassNames.toString());
      sw.append(", anc idx: " + ancestorIndices.toString());
      return sw.toString();
    }
    
    @Override
    public boolean equals(Object o) {
      PathToRoot that = (PathToRoot) o;
      if (this.depthFromRoot != that.depthFromRoot ||
          this.ancestorClassNames.size() != that.ancestorClassNames.size() ||
          this.ancestorIndices.size() != that.ancestorIndices.size()) {
        return false;
      }
      for (int i = 0; i < ancestorClassNames.size(); i++) {
        if (!this.ancestorClassNames.get(i).equals(that.ancestorClassNames.get(i))) {
          return false;
        }
      }
      for (int i = 0; i < ancestorIndices.size(); i++) {
        if (!this.ancestorIndices.get(i).equals(that.ancestorIndices.get(i))) {
          return false;
        }
      }      
      return true;
    }
  }


  @Override
  public HashMap getKeyValuePairs() {
    HashMap<String, String> hMap = new HashMap();

    
    Field[] fields = this.getClass().getDeclaredFields();
    for (int i = 0; i < fields.length; i++) {
      try {
        // clunky for pathToRoot and wAccessibilityText, 
        // but we won't be using the structured fields through the generic interface
        if (fields[i].get(this) != null) {
          hMap.put(fields[i].getName(), fields[i].get(this).toString()); 
        }
      } catch (IllegalArgumentException e) {
        e.printStackTrace();
      } catch (IllegalAccessException e) {
        e.printStackTrace();
      }
    }
    this.keyValuePairs = hMap;
    return hMap;
  }

  public int getEventType() {
    return eventType;
  }

  /**
   * AccessibilityEvents natively record time in seconds since epoch,
   * but QBDILA expects timestamps to be reported in milliseconds
   */
  @Override
  public long getTimeStamp() {
    if (timeStamp < Math.pow(10, 10)) { // we must be looking at seconds, not ms
      timeStamp = timeStamp * 1000; // convert to ms
    }
    return timeStamp;
  }

  public String getwText() {
    return wText;
  }

  public void setwText(String newText) {
    wText = newText;
  }

  public String getwClassName() {
    return wClassName;
  }

  public String getwPackageName() {
    return wPackageName;
  }

  public String getwResourceName() {
    return wResourceName;
  }

  public int getwHeight() {
    return wHeight;
  }

  public int getwWidth() {
    return wWidth;
  }

  public float getwRelativeHeight() {
    return wRelativeHeight;
  }

  public float getwRelativeWidth() {
    return wRelativeWidth;
  }

  public int getwXPos() {
    return wXPos;
  }

  public int getwYPos() {
    return wYPos;
  }

  public float getwRelativeXPos() {
    return wRelativeXPos;
  }

  public float getwRelativeYPos() {
    return wRelativeYPos;
  }

  public boolean iswIsEnabled() {
    return wIsEnabled;
  }

  public boolean iswIsChecked() {
    return wIsChecked;
  }

  public boolean iswIsFocused() {
    return wIsFocused;
  }

  public boolean iswIsFocusable() {
    return wIsFocusable;
  }

  public boolean iswIsCheckable() {
    return wIsCheckable;
  }

  public PathToRoot getPathToRoot() {
    return pathToRoot;
  }
  
  @Override
  public String getEventTypeName() {
    if (eventTypeName == null) {
      switch (getEventType()) {
        case TYPE_ANNOUNCEMENT: 
          eventTypeName = TYPE_ANNOUNCEMENT_NAME;
          important = false;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_GESTURE_DETECTION_END :
          eventTypeName = TYPE_GESTURE_DETECTION_END_NAME;
          important = true;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_GESTURE_DETECTION_START :
          eventTypeName = TYPE_GESTURE_DETECTION_START_NAME;
          important = true;
          startCandidate = true;
          stopCandidate = false;
          break;
        case TYPE_NOTIFICATION_STATE_CHANGED :
          eventTypeName = TYPE_NOTIFICATION_STATE_CHANGED_NAME;
          important = true;
          startCandidate = true;
          stopCandidate = true;
          break;
        case TYPE_TOUCH_EXPLORATION_GESTURE_END :
          eventTypeName = TYPE_TOUCH_EXPLORATION_GESTURE_END_NAME;
          important = false;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_TOUCH_EXPLORATION_GESTURE_START :
          eventTypeName = TYPE_TOUCH_EXPLORATION_GESTURE_START_NAME;
          important = false;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_TOUCH_INTERACTION_END :
          eventTypeName = TYPE_TOUCH_INTERACTION_END_NAME;
          important = false;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_TOUCH_INTERACTION_START :
          eventTypeName = TYPE_TOUCH_INTERACTION_START_NAME;
          important = false;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_VIEW_ACCESSIBILITY_FOCUSED :
          eventTypeName = TYPE_VIEW_ACCESSIBILITY_FOCUSED_NAME;
          important = false;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED :
          eventTypeName = TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED_NAME;
          important = false;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_VIEW_CLICKED :
          eventTypeName = TYPE_VIEW_CLICKED_NAME;
          important = true;
          startCandidate = true;
          stopCandidate = false;
          break;
        case TYPE_VIEW_FOCUSED :
          eventTypeName = TYPE_VIEW_FOCUSED_NAME;
          important = true;
          startCandidate = true;
          stopCandidate = true;
          break;
        case TYPE_VIEW_HOVER_ENTER :
          eventTypeName = TYPE_VIEW_HOVER_ENTER_NAME;
          important = false;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_VIEW_HOVER_EXIT :
          eventTypeName = TYPE_VIEW_HOVER_EXIT_NAME;
          important = false;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_VIEW_LONG_CLICKED :
          eventTypeName = TYPE_VIEW_LONG_CLICKED_NAME;
          important = true;
          startCandidate = true;
          stopCandidate = false;
          break;
        case TYPE_VIEW_SCROLLED :
          eventTypeName = TYPE_VIEW_SCROLLED_NAME;
          important = true;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_VIEW_SELECTED :
          eventTypeName = TYPE_VIEW_SELECTED_NAME;
          important = true;
          startCandidate = true;
          stopCandidate = false;
          break;
        case TYPE_VIEW_TEXT_CHANGED :
          eventTypeName = TYPE_VIEW_TEXT_CHANGED_NAME;
          important = true;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_VIEW_TEXT_SELECTION_CHANGED :
          eventTypeName = TYPE_VIEW_TEXT_SELECTION_CHANGED_NAME;
          important = true;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY :
          eventTypeName = TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY_NAME;
          important = false;
          startCandidate = false;
          stopCandidate = false;
          break;
        case TYPE_WINDOWS_CHANGED :
          eventTypeName = TYPE_WINDOWS_CHANGED_NAME;
          important = true;
          startCandidate = false;
          stopCandidate = true;
          break;
        case TYPE_WINDOW_CONTENT_CHANGED :
          eventTypeName = TYPE_WINDOW_CONTENT_CHANGED_NAME;
          important = true;
          startCandidate = false;
          stopCandidate = true;
          break;
        case TYPE_WINDOW_STATE_CHANGED :
          eventTypeName = TYPE_WINDOW_STATE_CHANGED_NAME;
          important = true;
          startCandidate = false;
          stopCandidate = true;
          break;
      }
    }
    return eventTypeName;
  }
  
  @Override
  public boolean isImportant() {
    getEventTypeName(); // force evaluation of importance
    return important;
  }
  
  @Override  
  public boolean isStartCandidate() {
    getEventTypeName(); // force evaluation of start candidacy
    return startCandidate;
  }
  
  @Override
  public boolean isStopCandidate() {
    getEventTypeName(); // force evaluation of stop candidacy
    return stopCandidate;
  }
  
  @Override 
  public String getComponentType() {
    return getwClassName();
  }
  
  @Override
  public String getComponentDescription() {
    String[] classNameParts = getwClassName().split("\\.");
    if (classNameParts.length > 1) {
      componentDescription = classNameParts[classNameParts.length - 1];
    } else {
      componentDescription = getwClassName();
    }
    return componentDescription;
  }

  @Override
  public String getComponentInfo() {
    return getwText();
  }

  @Override
  public String getModuleDescription() {
    String[] packageParts = getwPackageName().split("\\.");
    if (packageParts.length > 0) {
      return packageParts[packageParts.length - 1];
    } else {
      return getwPackageName();
    }
  }

  @Override
  public String getModuleName() {
    return getwPackageName();
  }


  
  public void setDistanceWeights(ALoggerDistanceWeights weights) {
    this.weights = weights;
  }
  
  
  public ALoggerDistanceWeights getDistanceWeights() {
    return weights;
  }
  
  @Override
  public float calculateDistance(Event event) {
    if (event instanceof AccessibilityLogEvent) {
      AccessibilityLogEvent otherEvent = (AccessibilityLogEvent) event;
      float dist = 0.0f;

      // key things: is this the same type of event?
      // is it on the same screen? (not sure we have a good way of detecting this)      
      // does it have the same path to the root?
      // do they have the same resource ID?

      if (otherEvent.getEventType() != getEventType()) {
        dist += 1.0f * weights.getEventTypeDifferenceWeight();
      }
      if (!otherEvent.getwPackageName().equals(getwPackageName())) {
        dist += 1.0f * weights.getPackageNameDifferenceWeight();
      }
      if (!otherEvent.getwClassName().equals(getwClassName())) {
        dist += 1.0f * weights.getClassNameDifferenceWeight();        
      }
      
      dist += calculateViewHierarchyDifference(otherEvent) *
          weights.getViewHierarchyDifferenceWeight();
      
      
      // (maybe) does it have the same text (useful for buttons)?
      // are they the same size and position on the screen (relatively speaking)?
      // --maybe need to see if the screen is in the same rotation 
      // --for this to make sense

      dist += calculateStringDistance(wText, otherEvent.getwText()) * 
          weights.getWidgetTextDifferenceWeight();
      
      if (dist < 0.0f) {
        Debug.log("distance is " + dist + " between " + toString() + " and " + event.toString());
      }
      return dist;
      
    } else {
      // compare them as Generic Events if arg is Generic
      return super.calculateDistance(event);
    }
  }

  /**
   * @param otherEvent
   * @return distance between events
   */
  private float calculatePathToRootDistance(AccessibilityLogEvent otherEvent) {
    PathToRoot otherPTR = otherEvent.getPathToRoot();
    PathToRoot thisPTR = getPathToRoot();
        
    float depthDiff = Math.abs(otherPTR.depthFromRoot - 
        thisPTR.depthFromRoot); // how much to penalize this?
    
    float pathDiff = Math.max(otherPTR.depthFromRoot, 
        thisPTR.depthFromRoot);
    String[] aClassNames = (String[]) thisPTR.ancestorClassNames.toArray();
    String[] oClassNames = (String[]) otherPTR.ancestorClassNames.toArray();
    Integer[] aIndices = (Integer[]) thisPTR.ancestorIndices.toArray();
    Integer[] oIndices = (Integer[]) otherPTR.ancestorIndices.toArray();
    
    for (int i = 0; i < aClassNames.length; i++) {
      for (int j = 0; j < oClassNames.length; j++) {
        if (aClassNames[i].equals(oClassNames[j])) {
          pathDiff += Math.abs(i - j); // same type of path element, but at a different point in the hierarchy
          if (!aIndices[i].equals(oIndices[j])) { // different children of same parent?
            pathDiff += 1.0f;
          }
        }
      }
    }
    
    return depthDiff + pathDiff;
  }
  
  private float calculateViewHierarchyDifference(AccessibilityLogEvent otherEvent) {
    
    if (getPathToRoot() == null && otherEvent.getPathToRoot() == null) {
      return 0.0f;
    } else if (getPathToRoot() == null) {
      return otherEvent.getPathToRoot().depthFromRoot;
    } else if (otherEvent.getPathToRoot() == null) {
      return getPathToRoot().depthFromRoot;
    }
    
    if (getPathToRoot().depthFromRoot < 2 || 
        otherEvent.getPathToRoot().depthFromRoot < 2) {
      return (Math.abs(getPathToRoot().depthFromRoot - 
          otherEvent.getPathToRoot().depthFromRoot));
    } // TODO: think about a better way to compare short paths
    
    String thisRootClassName = null;
    String otherRootClassName = null;
    try {    
      thisRootClassName = getPathToRoot().ancestorClassNames.get(getPathToRoot().depthFromRoot - 2);    
      otherRootClassName = otherEvent.getPathToRoot().ancestorClassNames.get(
          otherEvent.getPathToRoot().depthFromRoot - 2);
    } catch (Exception e) {
      Debug.log("exception examining " + toString() +
          " and " + otherEvent.toString() + ", " + 
          e.toString());
    }

    if (!thisRootClassName.equals(otherRootClassName)) {
      return Float.MAX_VALUE;
    }
    
    int i = getPathToRoot().depthFromRoot - 2;
    int j = otherEvent.getPathToRoot().depthFromRoot - 2;
    
    String[] aClassNames = 
        getPathToRoot().ancestorClassNames.toArray(new String[i]);
    String[] oClassNames = 
        otherEvent.getPathToRoot().ancestorClassNames.toArray(new String[j]);
    Integer[] aIndices = (Integer[])getPathToRoot().ancestorIndices.toArray(new Integer[i]);
    Integer[] oIndices = (Integer[])otherEvent.getPathToRoot().ancestorIndices.toArray(new Integer[j]);
    
    int commonAncestorIndex = 0;
    int oCommonAncestorIndex = 0;
    
    try {

      while(Math.min(i,j) >= 0) {
        if (!(aClassNames[i].equals(oClassNames[j]) &&
            aIndices[i].equals(oIndices[j]))) {
          commonAncestorIndex = i;
          oCommonAncestorIndex = j;
          break;
        }
        i--;
        j--;
      } 
    } catch (ArrayIndexOutOfBoundsException e) {
      Debug.log("Idx out of bounds when this event: " + toString() + " - " + getPathToRoot() + 
          " and other event: " + otherEvent.toString() + " - " + otherEvent.getPathToRoot());
    }
    // at the end of this we should've found a common ancestor where i + j > 0
    // or we should've exited the loop with i == 0 or j == 0
    // in any case, we can sum the distance to the common ancestor via i+j
    return (float) i + j + 2; // +2 because we went past when min(i,j)==0    
  }
  
  //credit to http://www.programcreek.com/2013/12/edit-distance-in-java/
  public static int calculateStringDistance(String word1, String word2) {
    if (word1 == null && word2 == null) {
      return 0;
    } else if (word1 == null) {
      return word2.length();
    } else if (word2 == null) {
      return word1.length();
    }
    
    int len1 = word1.length();
    int len2 = word2.length();
 
    //Debug.log("Comparing " + word1 + " and " + word2);
    // len1+1, len2+1, because finally return dp[len1][len2]
    
    int[][] dp = new int[len1 + 1][len2 + 1];
 
    for (int i = 0; i <= len1; i++) {
        dp[i][0] = i;
    }
 
    for (int j = 0; j <= len2; j++) {
        dp[0][j] = j;
    }
 
    //iterate though, and check last char
    for (int i = 0; i < len1; i++) {
        char c1 = word1.charAt(i);
        for (int j = 0; j < len2; j++) {
            char c2 = word2.charAt(j);
 
            //if last two chars equal
            if (c1 == c2) {
                //update dp value for +1 length
                dp[i + 1][j + 1] = dp[i][j];
            } else {
                int replace = dp[i][j] + 1;
                int insert = dp[i][j + 1] + 1;
                int delete = dp[i + 1][j] + 1;
 
                int min = replace > insert ? insert : replace;
                min = delete > min ? min : delete;
                dp[i + 1][j + 1] = min;
            }
        }
    }
    //Debug.log("Comparing " + word1 + " and " + word2);
 
    return Math.max(dp[len1][len2], Math.abs(len1 - len2));
  }
  
  @Override
  public String getIdentifier() {
    StringWriter sw = new StringWriter();
    sw.append(getEventTypeName() + "$" + getComponentType() + "$" + getModuleName());
    if (pathToRoot != null) {
      sw.append("$$" + "depth:" + pathToRoot.depthFromRoot);
      if (pathToRoot.ancestorClassNames.size() != pathToRoot.ancestorIndices.size()) {
        Debug.log("***** Ancestor class name and indices arrays are of different sizes!" +
            this.toString());
      }
      // note the identifier only includes the path to the parent.
      // this will allow controls that share the same parent to match if they are the same type
      for (int i = 0; i < pathToRoot.ancestorIndices.size(); i++) {
        sw.append("," + pathToRoot.ancestorClassNames.get(i)); 
        //  +":" + pathToRoot.ancestorIndices.get(i));
      }
    }
    identifier = sw.toString();
    return identifier;
  }
  
  public String toString() {
    StringWriter sw = new StringWriter();
    
    sw.append(getIdentifierId() + "-");
    sw.append(getEventTypeName() + "-");
    sw.append(getwClassName() + "-");
    sw.append(getwText() + "-");
    sw.append(getwPackageName());
    if (getwResourceName() != null) {
      sw.append("-" + getwResourceName());
    }
    sw.append("-" + getTimeStamp());
    sw.append("-" + getIdentifier());

    return sw.toString();
  }

  public boolean isSkippable() {
    for (int i = 0; i < generousFilterEvents.length; i++) {
       if (generousFilterEvents[i] == eventType) {
         return true;
       }
    }

    if (Config.useAggressiveFiltering) {
      for (int i = 0; i < aggressiveFilterEvents.length; i++) {
        if (aggressiveFilterEvents[i] == eventType) {
          return true;
        }
      }      
    }
    return false;
  }
  
  /* (non-Javadoc)
   * @see java.lang.Comparable#compareTo(java.lang.Object)
   */
  @Override
  public int compareTo(AccessibilityLogEvent that) {
    if (this.getTimeStamp() > that.getTimeStamp()) {
      return 1;
    } else if (this.getTimeStamp() == that.getTimeStamp()) {
      return 0;
    } else { // this < that
      return -1;      
    }
  }

  @Override
  public void init() {    
    this.displayEvent = getEventTypeName(); 
    this.displayTitle = getModuleDescription();
    String info = getComponentInfo();
    if (info == null) {
      info = this.getComponentDescription();
    }
    this.displayExtra = info;
    // see if time was reported seconds, not ms
    // 10^10 ms past the epoch occurred before May 1, 1970
    // 10^10 s past the epoch won't occur until arround 2290 AD
    if (timeStamp < Math.pow(10, 10)) { 
      timeStamp = timeStamp * 1000; // convert to ms
    }
    this.identifier = getIdentifier();
    this.identifierId = SearchEngine.getSearchEngine().retrieveOrRegisterIdentifier(identifier);

  }


  @Override
  public String getDisplayTitle() {
    return displayTitle;
  }

  @Override
  public String getDisplayEvent() {
    return displayEvent;
  }

  @Override
  public String getDisplayExtra() {
    return displayExtra;
  }
  
}
