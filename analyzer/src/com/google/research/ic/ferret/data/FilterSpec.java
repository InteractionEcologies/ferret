/*******************************************************************************
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package com.google.research.ic.ferret.data;

import com.google.research.ic.ferret.test.Debug;

import java.io.StringWriter;

/**
 * TODO: Insert description here. (generated by marknewman)
 */
public class FilterSpec {
  public static final String EQUALS = "EQUALS";
  public static final String NOT_EQUALS = "NOT_EQUALS";
  public static final String GREATER_THAN = "GREATER_THAN";
  public static final String LESS_THAN = "LESS_THAN";
  public static final String BETWEEN = "BETWEEN";
  
  private double minDist = 0.0;
  private double maxDist = 100.0;
  private int limit = -1;
  private int maxSubSequenceSize = -1;
  private int minSubSequenceSize = -1;
  
  private String attributeKey = null;
  private String operator = null;
  private Object value = null;
  private Object value2 = null; // used only for BETWEEN
  
  public FilterSpec(double minDist,
      double maxDist,
      int limit) {
    this.minDist = minDist;
    this.maxDist = maxDist;
    this.limit = limit;
  }

  public FilterSpec(double minDist,
      double maxDist,
      int limit,
      String attributeKey,
      String operator,
      Object value) {
    
    this(minDist, maxDist, limit);
    if (operator.equals(BETWEEN)) {
      throw new IllegalArgumentException("Must supply two values for BETWEEN operator");
    } else if (operator.equals(GREATER_THAN) || operator.equals(LESS_THAN)) {
      if (!(value instanceof Comparable)) {
        throw new IllegalArgumentException("Must supply a Comparable to use GREATER_THAN or LESS_THAN");
      }
    }
    this.attributeKey = attributeKey;
    this.operator = operator;
    this.value = value;
  }

  public FilterSpec(double minDist,
      double maxDist,
      int limit,
      String attributeKey,
      String operator,
      Object value,
      Object value2) {

    this(minDist, maxDist, limit);

    if (!operator.equals(BETWEEN)) {
      throw new IllegalArgumentException("Must use BETWEEN for constructor with two value args");
    } 
    if (!(value instanceof Comparable) || !(value2 instanceof Comparable)) {
      throw new IllegalArgumentException("Must supply a Comparable to use GREATER_THAN or LESS_THAN");
    }
    try {
      ((Comparable) value).compareTo(value2);
    } catch (Exception e) {
      throw new IllegalArgumentException("value and value2 are not comparable");
    }
    
    this.attributeKey = attributeKey;
    this.operator = operator;
    this.value = value;
    this.value2 = value2;
  }

  /**
   * @return the minDist
   */
  public double getMinDist() {
    return minDist;
  }

  /**
   * @param minDist the minDist to set
   */
  public void setMinDist(double minDist) {
    this.minDist = minDist;
  }

  /**
   * @return the maxDist
   */
  public double getMaxDist() {
    return maxDist;
  }

  /**
   * @param maxDist the maxDist to set
   */
  public void setMaxDist(double maxDist) {
    this.maxDist = maxDist;
  }

  /**
   * @return the limit
   */
  public int getLimit() {
    return limit;
  }

  /**
   * @param limit the limit to set
   */
  public void setLimit(int limit) {
    this.limit = limit;
  }

  /**
   * @return the attributeKey
   */
  public String getAttributeKey() {
    return attributeKey;
  }

  /**
   * @param attributeKey the attributeKey to set
   */
  public void setAttributeKey(String attributeKey) {
    this.attributeKey = attributeKey;
  }

  /**
   * @return the operator
   */
  public String getOperator() {
    return operator;
  }

  /**
   * @param operator the operator to set
   */
  public void setOperator(String operator) {
    this.operator = operator;
  }

  /**
   * @return the value
   */
  public Object getValue() {
    return value;
  }

  /**
   * @param value the value to set
   */
  public void setValue(Object value) {
    this.value = value;
  }

  /**
   * @return the value2
   */
  public Object getValue2() {
    return value2;
  }

  /**
   * @param value2 the value2 to set
   */
  public void setValue2(Object value2) {
    this.value2 = value2;
  }

  /**
   * @return the maxSubSequenceSize
   */
  public int getMaxSubSequenceSize() {
    return maxSubSequenceSize;
  }

  /**
   * @param maxSubSequenceSize the maxSubSequenceSize to set
   */
  public void setMaxSubSequenceSize(int maxSubSequenceSize) {
    this.maxSubSequenceSize = maxSubSequenceSize;
  }

  /**
   * @return the minSubSequenceSize
   */
  public int getMinSubSequenceSize() {
    return minSubSequenceSize;
  }

  /**
   * @param minSubSequenceSize the minSubSequenceSize to set
   */
  public void setMinSubSequenceSize(int minSubSequenceSize) {
    this.minSubSequenceSize = minSubSequenceSize;
  }

  public boolean filter(SubSequence subSequence) {
    
    if (minDist != -1.0 && subSequence.getDistance() < minDist) {
      return false;
    }
    if (maxDist != -1.0 && subSequence.getDistance() > maxDist) {
      return false;
    }
    if (minSubSequenceSize != -1 && subSequence.getLength() < minSubSequenceSize) {
      return false;
    }
    if (maxSubSequenceSize != -1 && subSequence.getLength() > maxSubSequenceSize) {
      return false;
    }
    if (attributeKey != null) {
      if (operator.equals(EQUALS)) {
        return (subSequence.getSnippet().getAttribute(attributeKey).getValue().equals(value));
      } else if (operator.equals(NOT_EQUALS)) {
        return (!subSequence.getSnippet().getAttribute(attributeKey).getValue().equals(value));
      } else if (operator.equals(GREATER_THAN)) {
        Comparable snipVal = (Comparable) subSequence.getSnippet().getAttribute(attributeKey).getValue();
        return (snipVal.compareTo(value) > 0);
      } else if (operator.equals(LESS_THAN)) {
        Comparable snipVal = (Comparable) subSequence.getSnippet().getAttribute(attributeKey).getValue();
        return (snipVal.compareTo(value) < 0);
      } else if (operator.equals(BETWEEN)) {
        Comparable snipVal = (Comparable) subSequence.getSnippet().getAttribute(attributeKey).getValue();
        Debug.log("Filtering to see if " + snipVal + "BETWEEN " + value + " and " + value2 );
        return (snipVal.compareTo(value) >= 0 && snipVal.compareTo(value2) <= 0);
      }
    }
    return true;
  }  

  @Override
  public String toString() {
  
    StringWriter sw = new StringWriter();
    sw.append("{ minDist: " + minDist
        + ", maxDist: " + maxDist
        + ", limit: " + limit
        + ", maxSubSequenceSize: " + maxSubSequenceSize
        + ", minSubSequenceSize: " + minSubSequenceSize
        + ", attributeKey: " + attributeKey
        + ", operator: " + operator
        + ", value: " + value
        + ", value2: " + value2
        + " }");

    return sw.toString();
  }
}
